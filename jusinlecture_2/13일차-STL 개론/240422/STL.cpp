#include "stdafx.h"

int main()
{
	// STL : 템플릿을 기반으로 하는 클래수와 함수들의 집합 라이브러리
	// c++에서 제공하는 라이브러리 일종으로 프로그래밍에 필요한 자료구조 및 알고리즘을 클래스 템플릿화하여 제공
	
	// 라이브러리 : 바이너리로 번역(컴파일)된 함수들을 모아놓은 파일

	// 코드 재사용을 위한 초창기 방법 중 하나, 다른 프로그램에서 사용할 수 있도록 운영체제나 소프트 웨어 개발자에 의해 제공
	// 라이브러리의 대다수 함수들은 함수의 정의 및 선언들을 필요로 하기 때문에 링크되기 전 전처리기에 의해 해당 헤더 파일을 원시 프로그램에 포함시켜야 한다.
	// 라이브러리들은 사용자의 프로그램과 링크되어 가능한 완전한 프로그램을 이루게 된다.


	// STL의 구성 요소

	// 1. 컨테이너 : 데이터를 저장하는 객체, 즉 자료구조를 구현한 객체(클래스 템플릿으로 설계됨)

	// 1-1. 원소 배치 방식에 따른 구분
	// 
	// 	- 표준 시퀀스 컨테이너 : vector, deque, list, array, forward_list
	// 
	// 	- 자동으로 정렬하는 연관 컨테이너 : set, multiset, map, multimap
	// 	- 자동으로 정렬하지 않는 연관 컨테이너 : unordered_set, unordered_multiset, unordered_map, unordered_multimap
	// 
	// 1-2. 메모리 저장 방식에 따른 구분
	// 
	// 	- 배열 기반 컨테이너 : vector, deque, array
	// 	- 노드 기반 컨테이너 : 나머지
	// 
	// 1-3. 컨테이너 어댑터 : 기존 컨테이너의 기능 중 일부 기능만을 사용 가능하며, 기능 제한이나 기능이 변형되어 있는 컨테이너
	// 	- stack, queue, priority_queue
	// 
	// 1-4. 근사(almost) 컨테이너 : 컨테이너로서의 조건을 모두 충족하지 못한 컨테이너
	// 	- string, wstring
	// 
	// 2. 알고리즘 : 컨테이너 내에서 정렬, 삭제, 탐색 등을 해결하는 일반화된 방법을 제공하는 함수 템플릿
	// 	- 대부분의 알고리즘 함수들은 특정 컨테이너 멤버가 아닌 전역으로 제공
	// 	- 일반화 프로그래밍의 개념상 다수 컨테이너가 적용할 수 있도록 범용적으로 작성했기 때문
	// 	- <algorithm> 헤더를 포함해야 사용 가능
	// 
	// 3. 함수 객체 : () 연산자 오버로딩을 통해서 객체를 함수처럼 사용하는 문법, 대개 STL 알고리즘의 조건자로 삽입하기 위해 생성하여 사용
	// 
	// 4. 반복자(이터레이터) : 포인터가 아닌 객체, 컨테이너마다 개별적인 반복자를 소유하고 있음, 컨테이너 내 원소를 접근하고 값을 읽거나 쓰는 용도의 객체


	return 0;
}